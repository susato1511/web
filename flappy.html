<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Flappy Bat</title>

<!-- âœ… Prevent mobile zoom -->
<meta name="viewport"
      content="width=device-width,height=device-height,initial-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover">

<link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32'%3E%3Ctext x='0' y='32' font-size='32'%3EðŸ¦‡%3C/text%3E%3C/svg%3E">

<style>
* {
    -webkit-user-select: none;
    -webkit-touch-callout: none;
    user-select: none;
}

body {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
    background: #000;

    touch-action: none;
    overscroll-behavior: none;
}

canvas {
    border: 1px solid #555;
    background: #1a1a1a;
    touch-action: none;
}

#score {
    position: absolute;
    top: 20px;
    font-size: 40px;
    font-family: Arial;
    color: #fff;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
}
</style>
</head>

<body>
<div id="score">0</div>
<canvas id="game" width="400" height="600"></canvas>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const scoreElement = document.getElementById('score');

/* ================== TEXTURES ================== */
function createCaveTexture(color) {
    const t = document.createElement('canvas');
    t.width = t.height = 32;
    const c = t.getContext('2d');
    c.fillStyle = color;
    c.fillRect(0,0,32,32);
    c.strokeStyle = '#00000030';
    c.lineWidth = 2;
    for (let i=0;i<8;i++) {
        c.beginPath();
        c.moveTo(Math.random()*32, Math.random()*32);
        c.lineTo(Math.random()*32, Math.random()*32);
        c.stroke();
    }
    return ctx.createPattern(t,'repeat');
}

const caveWallTexture = createCaveTexture('#332211');
const obstacleTexture = createCaveTexture('#553322');

/* ================== GAME STATE ================== */
const bat = {
    x: 80,
    y: 300,
    velocity: 0,
    gravity: 0.4,
    jump: -10,
    size: 40
};

const obstacles = [];
const gap = 200;
const obstacleWidth = 60;
const obstacleSpacing = 250;

let score = 0;
let gameOver = false;
let gameStarted = false;

/* ================== INPUT ================== */
function handleInput(e) {
    e.preventDefault();

    if (!gameStarted) {
        gameStarted = true;
        gameLoop();
        return;
    }
    if (!gameOver) bat.velocity = bat.jump;
    else resetGame();
}

canvas.addEventListener('touchstart', handleInput, { passive: false });
canvas.addEventListener('pointerdown', handleInput);

/* ================== GAME LOGIC ================== */
function resetGame() {
    bat.y = 300;
    bat.velocity = 0;
    obstacles.length = 0;
    score = 0;
    gameOver = false;
    gameStarted = true;
    scoreElement.textContent = '0';
    gameLoop();
}

function createObstacle() {
    const minHeight = 80;
    const maxHeight = canvas.height - gap - minHeight;
    const height = Math.random() * (maxHeight - minHeight) + minHeight;
    obstacles.push({ x: canvas.width, topHeight: height, passed: false });
}

function update() {
    if (!gameStarted || gameOver) return;

    bat.velocity += bat.gravity;
    bat.y += bat.velocity;
    bat.y = Math.max(bat.size/2, Math.min(canvas.height-bat.size/2, bat.y));

    if (!obstacles.length || obstacles.at(-1).x < canvas.width - obstacleSpacing)
        createObstacle();

    obstacles.forEach((o,i)=>{
        o.x -= 2;
        if (!o.passed && o.x + obstacleWidth < bat.x) {
            o.passed = true;
            score++;
            scoreElement.textContent = score;
        }
        if (o.x < -obstacleWidth) obstacles.splice(i,1);
    });

    const circle = { x: bat.x, y: bat.y, r: bat.size/2 };
    obstacles.forEach(o=>{
        if (hit(circle,o)) gameOver = true;
    });
}

function hit(c,o) {
    return c.y-c.r < o.topHeight && c.x+c.r>o.x && c.x-c.r<o.x+obstacleWidth ||
           c.y+c.r > o.topHeight+gap && c.x+c.r>o.x && c.x-c.r<o.x+obstacleWidth;
}

/* ================== DRAW ================== */
function draw() {
    const g = ctx.createLinearGradient(0,0,0,canvas.height);
    g.addColorStop(0,'#2a2a2a');
    g.addColorStop(1,'#000');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    ctx.fillStyle = obstacleTexture;
    obstacles.forEach(o=>{
        ctx.beginPath();
        ctx.moveTo(o.x,0);
        ctx.lineTo(o.x+obstacleWidth,0);
        ctx.lineTo(o.x+obstacleWidth/2,o.topHeight);
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(o.x,canvas.height);
        ctx.lineTo(o.x+obstacleWidth,canvas.height);
        ctx.lineTo(o.x+obstacleWidth/2,o.topHeight+gap);
        ctx.fill();
    });

    ctx.font = bat.size+'px Arial';
    ctx.textAlign='center';
    ctx.textBaseline='middle';
    ctx.fillStyle='#fff';
    ctx.fillText('ðŸ¦‡',bat.x,bat.y);

    if (!gameStarted) {
        ctx.font='32px Arial';
        ctx.fillText('Tap to Start',canvas.width/2,canvas.height/2);
    }
    if (gameOver) {
        ctx.font='40px Arial';
        ctx.fillText('Game Over',canvas.width/2,canvas.height/2);
        ctx.font='20px Arial';
        ctx.fillText('Tap to Restart',canvas.width/2,canvas.height/2+40);
    }
}

/* ================== LOOP ================== */
function gameLoop() {
    if (gameOver) return;
    update();
    draw();
    requestAnimationFrame(gameLoop);
}

draw();
</script>
</body>
</html>
